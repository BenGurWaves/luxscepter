<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ascend — Upload (Signed)</title>
<style>
  :root{--black:#000000;--gold:#D4AF37;--indigo:#4B0082;--red:#8B0000}
  html,body{height:100%;margin:0;background:var(--black);color:#eee;font-family:"Chomsky","Times New Roman",serif}
  .wrap{max-width:940px;margin:28px auto;padding:26px}
  h1{color:var(--gold);margin:0 0 6px 0}
  label{display:block;margin-top:12px;color:#ccc;font-size:13px}
  input[type="text"],input[type="email"],input[type="password"],textarea,select{width:100%;padding:10px;border-radius:6px;border:1px solid #222;background:#0c0c0c;color:#ddd}
  input[type="file"]{margin-top:12px}
  .row{display:flex;gap:12px}
  .col{flex:1}
  .btn{background:transparent;border:1px solid var(--gold);color:var(--gold);padding:9px 14px;border-radius:8px;cursor:pointer;margin-top:12px}
  .note{font-size:13px;color:#bbb;margin-top:10px}
  .status{margin-top:14px;padding:12px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-left:3px solid var(--indigo)}
  .small{font-size:12px;color:#bbb}
  .authBox{background:#070707;padding:12px;border-radius:8px;margin-bottom:14px;border:1px solid #222}
  .inline{display:inline-block}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Ascend — Upload</h1>
    <div class="note">You must be signed in to upload. If you don't have an account, sign up. (Email + password only.)</div>

    <div id="authArea" class="authBox">
      <div id="signedOutUI">
        <label>Email</label><input id="email" type="email" placeholder="you@royalrealm.com"/>
        <label>Password</label><input id="password" type="password" placeholder="strong password"/>
        <div style="margin-top:10px">
          <button class="btn" id="btnSignIn">Sign in</button>
          <button class="btn" id="btnSignUp">Sign up</button>
        </div>
        <div class="small" style="margin-top:8px;color:#999">Signing up will create a user in Supabase Auth. We will ask you to set a username on first sign-in.</div>
      </div>

      <div id="signedInUI" style="display:none">
        <div style="display:flex;align-items:center;gap:12px;">
          <div class="small">Signed in as <strong id="displayUsername">…</strong> (<span id="displayEmail">…</span>)</div>
          <div style="margin-left:auto">
            <button class="btn" id="btnSignOut">Sign out</button>
          </div>
        </div>
        <div id="usernameSetArea" style="margin-top:10px;display:none">
          <label>Choose a username</label>
          <input id="setUsername" type="text" placeholder="public username"/>
          <button class="btn" id="btnSetUsername">Save username</button>
        </div>
      </div>
    </div>

    <div>
      <label>Content Kind</label>
      <select id="kind">
        <option value="edict">Edict (vertical short)</option>
        <option value="dominion">Dominion (horizontal short)</option>
        <option value="throne">Throne (long-form)</option>
      </select>

      <label>Title</label>
      <input id="title" type="text" placeholder="Title — cinematic, minimal" />

      <label>Description</label>
      <textarea id="description" rows="3" placeholder="Short description"></textarea>

      <label>Choose video file</label>
      <input id="file" type="file" accept="video/*" />

      <div class="row" style="margin-top:10px">
        <button class="btn" id="uploadBtn">Upload to R2 + Save metadata</button>
        <button class="btn" onclick="location.href='index.html'">Back to Realm</button>
      </div>

      <div id="status" class="status" style="display:none"></div>
    </div>

    <div style="margin-top:16px;font-size:13px;color:#999">
      <div><strong>Notes:</strong></div>
      <div>- The author column in the DB will be set to your user UUID automatically (not shown to users).</div>
      <div>- If your R2 uploads fail due to CORS you must configure R2 bucket CORS (see instructions below).</div>
    </div>
  </div>

<script>
/* CONFIG — embedded in code as requested (this is visible to anyone who opens the file) */
const SUPABASE = {
  url: 'https://uewvmldolwgihfkxwlsl.supabase.co',
  anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVld3ZtbGRvbHdnaWhma3h3bHNsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5MzQ1MjksImV4cCI6MjA3OTUxMDUyOX0.b9C00OjIkAUDPztC8RtdHcwjdgX4OrShNW_pp6r-_qI'
};

/* Cloudflare R2 credentials — YOU ASKED ME TO PUT THESE INSIDE THE CODE.
   This is insecure when delivered to browsers. Prefer server-signed URLs.
*/
const R2 = {
  base: 'https://4aefdc871e931f0ca228941ee1599c02.r2.cloudflarestorage.com',
  bucketPath: '/luxscepter-uploads',
  accountId: '4aefdc871e931f0ca228941ee1599c02',
  accessKey: 'b1e60f0da846e830e9e77680cdf6eb3f',
  secretKey: '1a501b5c35f214508f03666242c8bf831373df226931670e7705e11966435dce'
};

/* UI bindings */
const btnSignIn = document.getElementById('btnSignIn');
const btnSignUp = document.getElementById('btnSignUp');
const btnSignOut = document.getElementById('btnSignOut');
const btnSetUsername = document.getElementById('btnSetUsername');
const statusEl = document.getElementById('status');
const signedOutUI = document.getElementById('signedOutUI');
const signedInUI = document.getElementById('signedInUI');
const usernameSetArea = document.getElementById('usernameSetArea');
const displayUsername = document.getElementById('displayUsername');
const displayEmail = document.getElementById('displayEmail');

let currentSession = null; // {access_token, user}
let currentProfile = null; // fetched profile row (may contain username)

/* Helper: show status */
function status(msg, isErr=false){
  statusEl.style.display = 'block';
  statusEl.style.borderLeftColor = isErr ? 'var(--red)' : 'var(--indigo)';
  statusEl.innerText = msg;
}

/* AUTH: sign up and sign in using Supabase Auth REST */
btnSignUp.addEventListener('click', async ()=>{
  const email = document.getElementById('email').value.trim();
  const password = document.getElementById('password').value;
  if(!email || !password) return status('Email + password required', true);
  status('Signing up...');
  try {
    const res = await fetch(`${SUPABASE.url}/auth/v1/signup`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE.anonKey
      },
      body: JSON.stringify({email, password})
    });
    const j = await res.json();
    if(!res.ok) throw new Error(j.msg || j.error_description || JSON.stringify(j));
    // on some setups signup returns session; try to use it to populate UI
    if(j && j.user){
      currentSession = {access_token: j.access_token || null, user: j.user};
      await postSignInInit();
    } else {
      status('Sign up ok. Check email for confirmation if required. Then sign in.', false);
    }
  } catch(err){
    console.error(err);
    status('Sign up error: ' + err.message, true);
  }
});

btnSignIn.addEventListener('click', async ()=>{
  const email = document.getElementById('email').value.trim();
  const password = document.getElementById('password').value;
  if(!email || !password) return status('Email + password required', true);
  status('Signing in...');
  try {
    const form = new URLSearchParams();
    form.set('grant_type','password');
    form.set('email', email);
    form.set('password', password);

    const res = await fetch(`${SUPABASE.url}/auth/v1/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'apikey': SUPABASE.anonKey
      },
      body: form.toString()
    });
    const j = await res.json();
    if(!res.ok) throw new Error(j.error_description || JSON.stringify(j));
    currentSession = {access_token: j.access_token, user: j.user};
    localStorage.setItem('supabase_session', JSON.stringify(currentSession));
    await postSignInInit();
  } catch(err){
    console.error(err);
    status('Sign in error: ' + err.message, true);
  }
});

btnSignOut.addEventListener('click', ()=>{
  currentSession = null;
  currentProfile = null;
  localStorage.removeItem('supabase_session');
  signedOutUI.style.display = '';
  signedInUI.style.display = 'none';
  usernameSetArea.style.display = 'none';
  status('Signed out');
});

/* After sign-in: fetch or create profile */
async function postSignInInit(){
  signedOutUI.style.display = 'none';
  signedInUI.style.display = '';
  displayEmail.innerText = currentSession.user.email || '(no-email)';
  // fetch profile row by id
  try {
    const hdrs = {
      'apikey': SUPABASE.anonKey,
      'Authorization': 'Bearer ' + currentSession.access_token
    };
    const r = await fetch(`${SUPABASE.url}/rest/v1/profiles?id=eq.${currentSession.user.id}`, {headers: hdrs});
    if(!r.ok) throw new Error('Failed to fetch profile: ' + r.status);
    const rows = await r.json();
    if(rows && rows.length>0){
      currentProfile = rows[0];
      displayUsername.innerText = currentProfile.username || '(set username)';
      usernameSetArea.style.display = currentProfile.username ? 'none' : '';
    } else {
      // no profile row — prompt to set username
      displayUsername.innerText = '(no username)';
      usernameSetArea.style.display = '';
    }
    status('Signed in as ' + (currentProfile && currentProfile.username ? currentProfile.username : currentSession.user.email));
  } catch(err){
    console.error(err);
    status('Could not load profile: ' + err.message, true);
  }
}

/* Save username (creates profiles row if needed) */
btnSetUsername.addEventListener('click', async ()=>{
  const uname = document.getElementById('setUsername').value.trim();
  if(!uname) return status('Enter a username', true);
  status('Saving username...');
  try {
    const hdrs = {
      'Content-Type': 'application/json',
      'apikey': SUPABASE.anonKey,
      'Authorization': 'Bearer ' + currentSession.access_token,
      'Prefer': 'return=representation'
    };
    // Try insert (id set to user id)
    const payload = { id: currentSession.user.id, username: uname };
    const r = await fetch(`${SUPABASE.url}/rest/v1/profiles`, { method: 'POST', headers: hdrs, body: JSON.stringify(payload) });
    if(!r.ok){
      // try patch if insert blocked
      const patch = await fetch(`${SUPABASE.url}/rest/v1/profiles?id=eq.${currentSession.user.id}`, { method: 'PATCH', headers: hdrs, body: JSON.stringify({ username: uname }) });
      if(!patch.ok) throw new Error('Failed to save username');
      currentProfile = (await patch.json())[0] || null;
    } else {
      currentProfile = (await r.json())[0] || null;
    }
    displayUsername.innerText = currentProfile.username;
    usernameSetArea.style.display = 'none';
    status('Username saved: ' + currentProfile.username);
  } catch(err){
    console.error(err);
    status('Could not save username: ' + err.message, true);
  }
});

/* Load session if present */
(function tryRestore(){
  const s = localStorage.getItem('supabase_session');
  if(s){
    try { currentSession = JSON.parse(s); postSignInInit(); } catch(e){ localStorage.removeItem('supabase_session'); }
  }
})();

/* UPLOAD FLOW — builds object key, signs with SigV4 using embedded keys, uploads to R2, then inserts row in contents with author = currentSession.user.id */
document.getElementById('uploadBtn').addEventListener('click', async ()=>{
  if(!currentSession || !currentSession.user) return status('You must sign in first', true);
  const file = document.getElementById('file').files[0];
  if(!file) return status('Choose a file', true);
  const kind = document.getElementById('kind').value;
  const title = document.getElementById('title').value || '';
  const description = document.getElementById('description').value || '';

  const ts = Date.now();
  const safeName = file.name.replace(/[^a-zA-Z0-9.\\-\\_\\.]/g,'_');
  const key = `${kind}/${ts}_${Math.random().toString(36).slice(2,9)}_${safeName}`;
  const objectPath = `${R2.bucketPath}/${key}`; // /luxscepter-uploads/...
  const objectUrl = `${R2.base}${objectPath}`;

  status('Uploading ' + safeName + ' to R2...');

  try {
    // Upload via client-signed PUT
    const uploadResp = await uploadToR2Signed(R2.base, objectPath, file, R2.accessKey, R2.secretKey);

    if(!(uploadResp.status >=200 && uploadResp.status <300)){
      // if CORS silence: uploadResp may be undefined or fetch throws; handle below.
      throw new Error('R2 upload failed: ' + uploadResp.status + ' ' + uploadResp.statusText);
    }

    status('Upload complete. Saving metadata to Supabase...');

    const payload = {
      author: currentSession.user.id,
      kind: kind,
      title: title,
      description: description + '\\n\\nr2_url:' + objectUrl,
      duration_seconds: 0,
      is_draft: false,
      published_at: new Date().toISOString(),
      created_at: new Date().toISOString()
    };

    const hdrs = {
      'Content-Type': 'application/json',
      'apikey': SUPABASE.anonKey,
      'Authorization': 'Bearer ' + currentSession.access_token,
      'Prefer': 'return=representation'
    };

    const res = await fetch(SUPABASE.url + '/rest/v1/contents', { method: 'POST', headers: hdrs, body: JSON.stringify(payload) });
    if(!res.ok) {
      const t = await res.text();
      throw new Error('Supabase insert failed: ' + res.status + ' ' + t);
    }
    const inserted = await res.json();
    status('Saved. Content id: ' + (inserted[0] && inserted[0].id ? inserted[0].id : '(unknown)'));
    // redirect to watch page
    if(inserted && inserted[0] && inserted[0].id) {
      setTimeout(()=> location.href = 'watch.html?id=' + encodeURIComponent(inserted[0].id), 700);
    }
  } catch(err){
    console.error(err);
    // Special handling for CORS-like failures
    if(err.message && (err.message.includes('Failed to fetch') || err.message.includes('NetworkError') || err.message.includes('CORS') || err.message.includes('403'))){
      status('Upload failed. Likely CORS or permissions issue. Configure Cloudflare R2 CORS and confirm the bucket allows PUTs. See instructions below.', true);
    } else {
      status('Upload error: ' + err.message, true);
    }
  }
});

/* ----------------
   Minimal SigV4 signing for S3-compatible R2 (client-side)
   This is compact and works for moderate testing only.
   ---------------- */
async function sha256Hex(data){
  const buff = (data instanceof ArrayBuffer) ? data : new TextEncoder().encode(data);
  const hash = await crypto.subtle.digest('SHA-256', buff);
  return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function hmacBytes(keyBytes, msg){
  const cryptoKey = await crypto.subtle.importKey('raw', keyBytes, {name:'HMAC', hash:'SHA-256'}, false, ['sign']);
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, new TextEncoder().encode(msg));
  return new Uint8Array(sig);
}
function toHex(u8){ return Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function getSigningKey(secret, dateStamp, region, service){
  const kDate = await hmacBytes(new TextEncoder().encode('AWS4' + secret), dateStamp);
  const kRegion = await hmacBytes(kDate, region);
  const kService = await hmacBytes(kRegion, service);
  const kSigning = await hmacBytes(kService, 'aws4_request');
  return kSigning;
}

async function uploadToR2Signed(baseUrl, objectPath, file, accessKey, secretKey){
  // objectPath must start with /bucket/object...
  const url = new URL(baseUrl);
  const host = url.host;
  const method = 'PUT';
  const service = 's3';
  // Cloudflare R2 may use 'auto' or 'us-east-1' in the credential scope. If you get signature failures, try changing region below.
  const region = 'auto';
  const now = new Date();
  const amzDate = now.toISOString().replace(/[:-]|\.\d{3}/g,'') + 'Z';
  const dateStamp = amzDate.slice(0,8);
  const payloadArrayBuffer = await file.arrayBuffer();
  const payloadHash = await sha256Hex(payloadArrayBuffer);

  const canonicalUri = objectPath;
  const canonicalQueryString = '';
  const canonicalHeaders = `host:${host}\nx-amz-content-sha256:${payloadHash}\nx-amz-date:${amzDate}\n`;
  const signedHeaders = 'host;x-amz-content-sha256;x-amz-date';
  const canonicalRequest = [method, canonicalUri, canonicalQueryString, canonicalHeaders, signedHeaders, payloadHash].join('\n');
  const hashCanonical = await sha256Hex(new TextEncoder().encode(canonicalRequest));
  const credentialScope = `${dateStamp}/${region}/${service}/aws4_request`;
  const stringToSign = ['AWS4-HMAC-SHA256', amzDate, credentialScope, hashCanonical].join('\n');
  const signingKey = await getSigningKey(secretKey, dateStamp, region, service);
  const signature = toHex(await hmacBytes(signingKey, stringToSign));
  const authorization = `AWS4-HMAC-SHA256 Credential=${accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
  const uploadUrl = baseUrl + canonicalUri;

  const resp = await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
      'Content-Type': file.type || 'application/octet-stream',
      'x-amz-date': amzDate,
      'x-amz-content-sha256': payloadHash,
      'Authorization': authorization,
      'x-amz-acl': 'public-read'
    },
    body: file
  });
  return resp;
}

/* End of script */
</script>
</body>
</html>
